#!/bin/bash
# a bash loop to run things in the background
# uses my evry tool to run commands periodically
# https://github.com/seanbreckenridge/evry
# also runs any other bash scripts in this directory
# that end with .job

# Function to test if a command is on the users $PATH
# i.e. if they have a binary/script installed
havecmd() {
	if command -v "$1" >/dev/null 2>&1; then
		return 0
	else
		printf "Could not find %s on your \$PATH\n" "$1" >&2
		return 1
	fi
} && export -f havecmd

##### SETUP #####

declare -rx LOCKFILE="${BGPROC_LOCKFILE:-/tmp/bgproc.lock}"
declare -rx LOGFILE="${BGPROC_LOGFILE:-/tmp/bgproc.log}"
declare -rx SLEEP_TIME="${BGPROC_SLEEPTIME:-60}"

declare -a required_binaries
required_binaries=('evry')
for binary in "${required_binaries[@]}"; do
	havecmd "$binary" || exit $?
done

##### OUT/ERR LOGGING FUNCTIONS #####

# both of these accept one argument, which is the message to print

# print a log to STDOUT and append to logfile
printlog() {
	printf "$(date +%s):%s\n" "$1" | tee -a "$LOGFILE"
} && export -f printlog

# print a log to to STDERR, and append to the logfile
# if notify-send (to send a notification on linux) is
# available, also sends a notification
send-error() {
	printf '%s:error:%s\n' "$(date +%s)" "$1" >>"$LOGFILE"
	printf '%s\n' "$1" >&2
	havecmd notify-send 2>/dev/null && notify-send -u critical "bgproc error" "$1"
} && export -f send-error

##### LOCKFILE #####

# exit if lock file already exists
if [[ -e "$LOCKFILE" ]]; then
	send-error "Lockfile at ${LOCKFILE} already exists, exiting..."
	exit 1
fi

# delete lockfile when bgproc exits
cleanup() {
	rm "$LOCKFILE"
}
trap cleanup EXIT

# create lockfile
touch "$LOCKFILE"

#### CORE FUNCTIONALITY ####

# shorthand to list all jobs
job_list() {
	find . -type f -name "*.job" -print0
}

# print a list of all of the jobs
print_jobs() {
	printlog "Job List:"
	while read -r -d $'\0' script; do
		printlog "$script"
	done < <(job_list)
}

# read in jobs, run each of them
loop_iteration() {
	while read -r -d $'\0' script; do
		bash "$script" 2>&1
	done < <(find . -type f -name "*.job" -print0)
}

# main, background loop
bgproc_loop() {
	printlog "Sleep duration: $SLEEP_TIME"
	printlog "Starting loop..."
	print_jobs
	while true; do
		loop_iteration
		sleep "$SLEEP_TIME"
	done
}

#### MAIN ####

# handle flags and run
while getopts 'hod' opt; do
	case "$opt" in
	h)
		echo "Runs tasks in the background. Run without flags to start the background loop"
		echo "	-o		Runs the task loop once"
		echo "	-d		Runs the task loop once, in debug mode"
		echo "See https://github.com/seanbreckenridge/bgproc for more info"
		exit 0
		;;
	o)
		print_jobs
		loop_iteration
		exit 0
		;;
	d)
		print_jobs
		EVRY_DEBUG=1 loop_iteration
		exit 0
		;;
	*)
		exit 1
		;;
	esac
done

bgproc_loop
